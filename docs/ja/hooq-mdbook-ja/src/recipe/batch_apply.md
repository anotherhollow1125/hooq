# mod以下の関数に一括適用

実はhooqマクロは関数だけではなく処理構文を含むアイテムに付与が可能です。

ここでいう"アイテム"とは、Rustの手続きマクロ(あるいは文法)用語で、関数・mod・implブロック・traitブロック...など、直接ファイル直下に置ける文法要素( `Things that can appear directly inside of a module or scope.` )です。ただし処理構文を含まないアイテムについては無関係です。詳細はsynクレートの [Item](https://docs.rs/syn/latest/syn/enum.Item.html) を見てください。

ともかく、( `mod xxx;` という形ではない、中括弧を持った)modが定義されている時に、modに `#[hooq]` マクロを付けるとその内側の関数については `#[hooq]` を付けなくてもフックが行われるようになります。

この再帰的性質はmodに限りません。関数の中に関数やクロージャがネストしている場合、内側の関数やクロージャに対しても `#[hooq]` は設定に従い貪欲にメソッドをフックします。(コンパイルエラーにならないうちは、その方がデバッグがはかどりますよね？コンパイルエラーになる場合は `#[hooq::skip_all]` を付けてください。)

というわけで、良い機会なのでhooqの性質がわかるパズルを用意してみました。コメントに(英語で)理由を付記しましたが、関数やクロージャの中の値がどういう場合にフックされるか考えながら読んでみてください。

```rust
{{#rustdoc_include ../../../../../mdbook-source-code/recipe-batch-apply/src/main.rs}}
```

展開結果は次のようになります。かなり自然に、しかしマクロにしては[^macro]貪欲にフックを仕掛けられていると思います。

```bash
{{#include ../../../../../mdbook-source-code/recipe-batch-apply/src/main.expanded.rs:7:38}}
```

[^macro]: 手続きマクロにはあまり高度なリフレクション機能がないので、型推論で `Result` 型かどうか判別したりはできません。
