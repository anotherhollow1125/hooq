# todo

- [x] 関数の `return` をつけていない返り値にも対応する
- [x] 特殊文法に対応
  - [x] `$expr`: フックする対象式の内容をそのまま出力
  - [x] `$nth` / `$count`: 何番目の `?` / `return` かと、その種別を示す
    - 最後の返り値である場合はそのことも示す
  - [x] `$tag`: タグがある場合にそれを出力。ない場合は `(no tag)` を出力
    - あらかた実装はできたのでチェックを入れた
  - [x] `$line`: 行番号を出力 ( `nightly` では正確な位置、 `stable` では `line!()` を利用 )
    - Span情報を利用
  - [x] `$file`: ファイル名を出力
    - ~~Span情報を利用~~
    - ~~`file!()` マクロでも可で、同じ結果が得られると考えられるが、一応仕組みが異なる~~
      - ~~将来的にモジュールにもouter attributeで付与できる機能を導入する場合、 `Span` 情報を利用した場合との差が出ると考えられる~~
      - `nightly` だけならばいざ知らず、 `procmacro2_semver_exempt` が必要になったためただのエイリアスにすること決定！
  - [x] `$fn`: 関数の情報を出力
    - [x] ~~`$fn_pos`: 関数の位置を出力。仕組みは `line!()` を利用~~
      - `$line` ( `line!()` ) を活用すれば良いため使用しないこととした
    - [x] `$fn_name`: 関数名を出力
    - [x] `$fn_sig`: 関数のシグネチャを出力
    - [x] ~~`$fn_path`: 関数のパスを出力~~
      - 取得難易度が高い & `$file` ( `file!()` ) を活用すれば良いため使用しないこととした
- [x] テストを用意し始める
- [x] `skip` を `skip_all` か `ignore_all` に、部分的に無視するものを `skip` にする
  - [x] 伴い、 `skip` したときに内側のアトリビュートが残ってしまわないように直す
  - [x] `skip` / `skip_all` 用のテストを用意
  - [x] `skip` の仕様を詰める
    - スコープ単位での調整が吉？ -> そうした
  - [x] skip のテストを全部の構文要素について用意
- [x] `$expr` の挙動を直す
  - `#[cfg(all())]` や実際に付与されたフックなどマクロの副作用を受けてしまっているので、副作用を受けていないものをなんとかして取得したい
  - 属性は出力しない
  - `$expr` の元となるものを取得するタイミングを考える
    - 再帰呼び出し前に持ってくる
- [x] ~~verbose/depth 的なオプションを設定~~
  - ~~当初は全部につけるようにしていたけどこれだと表示がうるさいので表面だけ/全部につけるを付け替えたい~~
  - ~~伴い、 `#[hooq::force]` がある場合は絶対につけるみたいなオプションがほしい~~
  - 一晩考えたけどやっぱり全部につける & 要らない所は `#[hooq::skip]` かなぁ...
  - 局所的に出力を飛ばすオプションはほしい...？
- [x] trait_use の実装
  - [x] `use XXX as _;` をしかるべき場所に吐き出す
  - [x] マクロ以外も提供できるようにするためにワークスペースとする
  - [x] `HooqMeta` を提供し、 `custom` でうまく活用できるようにする
    - [x] 内部では `HashMap<String, Rc<dyn Any>>` を利用
  - [x] `HooqMeta` 自体を受け取れるメタ変数を用意
- [x] ~~extra_vars~~ 改め bindings
  - `tag` ではなく、 任意の変数と任意のExprをストックできる
  - というかいっそこちらで予約していない変数は自由に入れられるようにするか
  - `#[hooq::hoge("")]` == `#[hooq::var(hoge = "")]` みたいな機能にしてみる
- [x] メソッドを文中アトリビュートでの指定にも対応 (メソッドオーバーライド)
- [x] tag などについてルートとなる関数でも対応 (機能追加に時間がかかりそうだったため一旦TODOとした。該当箇所にTODOをつけている)
  - `tag` だけ先に対応済みだった。下のタスクを行うこと
- [x] `HooqOption` を `Context` に統合する
- 現状は関数に対しての outer attribute としてのみ
  - [x] モジュールへの outer attribute / inner attribute に対応する
  - この場合の挙動は、モジュール内でトップに定義された全ての関数へのフック付与
    - ~~上述の `$file` 変数について、作り方次第では杞憂で終わる可能性もあるため、YAGNIを破る感じにはなる...~~
    - その作り方次第の詳細: `#[hooq]` により `#[hooq]` を関数の属性としてつける場合問題なくなる可能性。検証してみないとわからないけども(多分無理)
    - [x] 上述の通りとしたのでモジュールに outer attribute として付与した場合、正確な位置を示さなくなる可能性が出てきた。要検証
      - `Span::line` 等を使うようになってきたのとテストを増やしたのでとりあえず大丈夫とする
  - 無理そう...: https://github.com/rust-lang/rust/issues/54726
- [x] ~~悩んでいる機能: `#[hooq::force]`~~
  - ~~強制的に付与することを示すアトリビュート~~
  - ~~でもこういうことしたいなら明示的に書いたほうが良いのでは...？~~
  - ~~もっとも、hooqの設定をそのまま適用させたいみたいなニーズには答えられそうではある~~
  - ~~ `#[hooq::skip_all]` 中に強制付与できるのは普通に強いので、入れても良いような気はしている~~
  - `#[hooq::skip]` を直感的にわかりやすいスコープ管理のものとしたため、必須ではなくした
  - 後述しているが、 `Result` だけでなく `MyResult` に対応できたり、 `Ok` へのフックのオンオフができたりを、オプションで表現したい
    - これができれば `#[hooq::force]` は不要と考えられる
- [x] `#[cfg(all())]` も残さないようにする
- [x] マクロの中も見るようにする
- ~~以下は余力があれば~~
- ~~[ ] `$mod`: モジュールの情報を出力~~
  - ~~[ ] `$mod_name`: モジュール名を出力~~
  - ~~[ ] `$mod_path`: モジュールのパスを出力~~
- ~~[ ] `$crate`: クレートの情報を出力~~
  - ~~[ ] `$crate_name`: クレート名を出力~~
  - ~~[ ] `$crate_path`: クレートのパスを出力~~
- [x] nightly を外す
- [x] `$file` について、絶対パスではなく相対パスを指定するバリエーションのものも用意
  - `Span::file` を利用する形にしたところ逆になった ( `Cargo.toml` があるとき相対パスになった) ので今度は逆に常に絶対パスを表示する手段を提供したい
- [x] `TraitItem` と `Item::Const` への対応
  - [x] 実装
  - [x] テスト
- [x] inert_attr 機能の強化
  - [x] デフォルトでは debug 時のみ出力とし、 release 時出力を指定するためのオプションを設ける
    - `#[cfg_attr(debug_assertions, hooq)]` で目的通りになったので機能自体不要と判明
      - チュートリアルや examples にこれの使用例を記載したい
  - 現在の実装では関数の返り値型が `Result` 型で**ない**時でも最後の式が `Ok` / `Err` であればフックしてしまう。
    - しかし、例えば `Result<T, E>` 型ではなく `MyResult<T>` だったりした際のフックを考えるとむしろこちらの仕様の方が親切で、 `#[hooq::skip]` で対応させる方が正しいのではないかという気持ちもある
    - feature や属性オプションを再考する際に存在だけ思い出してほしいかも
    - ↑ 上述に伴い、 ~~feature で~~ inert_attr および flavor で各ハードコードをコンフィグ可能にする
      - [x] `?` にフックするか否か
      - [x] `return xxx;` にフックするか否か
      - [x] 関数の最後の評価値にフックするか否か
      - [x] 返り値の式が `Ok(...)` ・ `Err(...)` ・ `Xxx(...)` の時にはフックするといった設定ができるか
      - [x] 関数の返り値型が `Result` ではない( `MyResult` などである)時にもフックするといった設定ができるか
      - [x] マクロの中身まで見るか (デフォルト: 見る)
    - feature だと複雑なのでやめる
  - [x] テストを用意する
- [x] `use_hook_method` の削除
  - flavor で入れるため削除する
  - [x] ついでにflavorはすでに受け入れるようにした
- [x] デフォルトの `tail_expr_idents` から `"Ok"` を削除し、テストを更新する
- [x] `cargo sort` をCIに入れる
- [x] `cargo build --timings html` の検討及び良さそうであればCIに入れる
- [x] tomlで設定可能にする機能
  - `flavor` で設定可能にする。 `flavor` は階層構造になっていて、基本親の設定を子が継承し、子は設定をオーバーライドできるようになっている
  - `[xxx.yyy] == __base__.xxx.yyy flavor` みたいな感じ
  - 設定項目は以下
    - `method`
    - `trait_use` (Contextには入らずルートでしか効果を発揮しない)
    - `hook_targets`
      - `?`
      - `return`
      - `tail_expr` / `tail-expr` / `tailexpr`
    - `tail_expr_idents`
      - `Err`
      - `Ok` (Option)
    - `result_types`
      - `Result`
    - `hook_in_macros`
      - true (default)
    - `bindings`
  - プロジェクトルートに `hooq.toml` がある場合それを参照
    - preset を自分で追加
    - `hooq.toml` はプロジェクトルートから現在対象としているファイルパス上のどこかにあればそれを読み込むようにしたい
      - キャッシュ機構あった方がよさそう
      - 時間かかりそうなのでこちらは急がないtodo.mdに記載
  - [x] `toml_load!()` マクロでロードすることにする
    - `toml_load!()`: プロジェクトルートまたはカレントディレクトリの `hooq.toml` を読み込む
      - どちらを読み込むかは `CARGO_MANIFEST_DIR` の有無で決める
    - `toml_load!(toml = "...")` / `toml_load!("...")`
      - `"..."` の中身がファイルパスの場合はファイルを読み込み、tomlが直接書かれている時はtomlを直接受け取る
    - `toml_load!(path = "...")` / `toml_load!(file = "...")`: 指定されたパスのtomlファイルを読む
    - `toml_load!(content = "...")`: 中身をtomlだと想定して受け取る
  - [x] `hook(path::to::Trait)` 記法 ( 旧 `custom` 機能 ) をほかのプリセットでも可能とする
    - そもそもこの記法やめる？
      - `flavor(trait_use(path::to::Trait, path::to::Trait2, ...))` がよさそう？
      - **複雑になりすぎるのでやめる** 。
      - [x] `hook` だけ特別扱いしようかとも思ったけどそれもやめる
      - `#[hooq(trait_use(...), flavor = "hook")]` 等はあり
        - [x] flavor 実装後、上記のように書けるようにする (テストで確認)
  - **`trait_use` を消す** ...？
    - もともと `dev` / `release` での付与切り替えに付随させるつもりで考えた機能だった
    - `dev` / `release` はユーザー側で付け替えることとしたので不要になった
    - が、flavor に頼らない状態でも同機能にアクセスできるようにはしておきたいので残す
  - `inert_attr` へのflavor導入について
    - わかりやすさのため & 実装の容易さのために一旦対応しないこととする
    - 「検討中」を参照のこと
  - [x] special flavors
    - [x] `__base__` (便宜上このように表しているだけで名前指定なし)
      - すべてのflavorの基礎となるflavor
      - 依存関係ツリーとしてはすべてのflavor `xxx` は実質 `__base__.xxx` みたいな関係になっている
        - すべてのflavorは `__base__` の上書きである
        - 上書き不可 (しようにも名前はないのでできない)
    - [x] `default`
      - `#[hooq]` とした際のデフォルト
      - `hooq.toml` では上書きして利用する想定
      - `default` のデフォルト(ややこしい)は `__base__`
    - [x] `empty`
      - **上書き不可** (エラーにする)
      - `method` が空のフレーバー
      - その他も空
      - 不活性アトリビュートを取り除く目的で指定
        - release ビルドなどで活躍
      - `#[cfg_attr(not(debug_assertions), hooq(empty))]` みたいな使い方を想定
  - [x] 関係するテストを実装する
    - [x] スペシャルflavor
      - `__base__`
      - [x] `default`
      - [x] `empty`
    - [x] カスタムflavor
      - [x] `hooq.toml` ロード周り
        - [x] 直接埋め込んだりできるか？
        - [x] ちゃんとロードされるか？
          - macrotest だとうまく行かなかったので macrotest は諦める
      - [x] サブflavor
      - [x] エラー時の flavor サジェスト (確認のみ)
      - [x] toml パース失敗時のエラーメッセージ表示 (確認のみ)
    - [x] `hook` 関連のテスト
      - [x] `#[hooq(trait_use(...), flavor = "hook")]` が書けるようになっていることのテスト
  - [x] 違うクレートの違う `hooq.toml` であっても、ワークスペースであったりすると他のクレートにエディタ側で共有してしまいエラーになってしまう模様。その解決
    - 正直どうすればよいか思いつかず
    - クレートID的なのをキーにする...？
      - (ロードするtomlファイルのパスとは無関係に) `CARGO_MANIFEST_PATH` をキーにするか
  - [x] ファイルパスの起点をちゃんとSpanのカレントディレクトリにする
- [x] 最初のリリースノートの作成
- [x] リリース用のGitHubアクションを設ける
- [x] ~~間違ってtomlへの依存を設けてしまったので消す~~
  - 上記が勘違いで必要なtomlだった
- [x] ドキュメント内の相対パスが軒並みバグっているのでURLに変更する
  - URL差し込み機能をスクリプトに設ける感じで

# 急がないtodo

急がないtodoの中でリリース前にやっておきたいものに @ を付与

- [x] `$expr` -> `$expr_str` へのリネーム
  - 検討中を参照のこと
- [ ] `$parent_method` でメソッド上書き時に元のメソッドも活用できるようにする
- [ ] `$expr` の出力する情報が多いので、出力を控えたものも用意する
- [ ] `fn_info` におけるクロージャの出力について、どの関数の中のクロージャであるか明記できるようにする
- [ ] 残りのフレーバーの用意
  - preset flavors
    - preset flavor は上書き可能
    - [x] `custom` -> `hook` にリネーム
      - [x] 改めて `hook` flavor 用意
    - [x] `log`
    - [x] `anyhow`
    - [ ] `eyre`
    - [ ] `tracing`
  - 名前について、
    - preset: 前述で表しているようにこちらで使用するflavorを preset flavors とした
    - [x] flavor
    - ~~setting~~: setting_file と被るのでなし
    - template
    - 上記のうちどれがよいか決める: 決定。flavorで
- [ ] mdBook の用意
  - `#[cfg_attr(debug_assertions, hooq)]`
    - チュートリアルや examples に↑の使用例を記載
- [ ] 足りないテストを追加し、examplesも機能を十分表せるように拡充する
  - [ ] examples 以下の内容も expand 自動化
- [x] エラーメッセージの開始が大文字小文字で表記ゆれしているので、小文字始まりで統一する
- [x] 誤字修正: `skiped` -> `skipped`
- [ ] dependabot の挙動調査および必要なら修正
- [ ] 軽量化のため、 syn の feature を見直す
- [x] cargo プロジェクトではないrustcでコンパイルする場合でも `toml_load!()` でカレントディレクトリの `hooq.toml` を読み込むことの確認
- [ ] 「`Ok(...)` がtail exprに来る時はフックしない」などを表す `tail_expr_idents` のブラックリスト版を作る
  - `not_tail_expr_idents` とかでいいか
- [ ] `toml_load!()` マクロを廃止し、ファイルパスは各マクロ呼び出しで指定するようにする。キャッシュ機構のみ設ける
- [ ] `#[hooq::method = flavor_name]` での上書きにする

# 検討中

- [ ] `$var(xxx)` or `$binding(xxx)`: `line` などもユーザーが自由に設定できるようにする
- [ ] `$get_or_default(xxx, Expr)`: もし存在しない binding の場合、 `Expr` を適用
  - 設定ファイルでデフォルト値を設けておくのもあり
  - だけど、設定ファイルに頼らなくてよいという利点もある
- [ ] `#[hooq(hooq_toml = "rel_file/to/hooq.toml", flavor = "...")]` でも設定可能にする
  - `toml_load!()` に頼る設計の方がわかりやすい&実装しやすいので没で...
- ~~[x] `#[hooq::method = "rel_file/to/hook.rs"]`~~
  - ~~上記のように書くことで外部ファイルにかかれたメソッドをフックできる機能~~
  - `#[hooq::method = flavor_name]` での上書きにする
- [ ] すべてのフックについて `return_type_is_result` を参照するか否か
  - `?` であったとしても「返り値型が明確に `result_types` に含まれない時(返り値型が明記されていて異なる時)」(以降<★の時>と呼ぶ) はフックをやめるようにするか
    - これはネストにある関数/クロージャの返り値型だけ `Option` の場合などでありレアケースであるため正直考慮する必要はない
    - 基本的に `#[hooq::skip_all]` で対応してほしい
  - 同様に `return` や最後の式についても、 `tail_expr_idents` に含まれる対象であったとしても<★の時>はフックをやめるようにするか
    - これこそ `Err(...)` が関数でも定義されていてそっちが呼び出されるみたいなレアケース中のレアケースだとは思う
- `hooq.toml` からさらにサブファイルにアクセスできるようにする
  - `[members]` セクションで指定
- [ ] `hooq.toml` はプロジェクトルートから現在対象としているファイルパス上のどこかにあればそれを読み込むようにする
  - そのファイルパスまでにある `hooq.toml` をすべてロードし、一番近いファイルの内容で上書きされるようにする
  - キャッシュや変更検知がとても大変なので没予定
- `#[hooq]` や `#[hooq::hooq]` などのネストに関しては無視するようにする
  - こうすると難しいことをせずともflavorの切り替えが容易になる
  - `use hooq::hooq as hoge;` とかされたら回避のしようがないがこういうのは無視する
- `hooq::method` に格納されている構文がドットで始まるか否かでフックのモードを変える機能
  - もしドット始まりではない場合、特殊な変数 `$expr` (現在の文字列として取得できる `$expr` とは非互換になる) を利用して元の構文にアクセスできるようにする
    - [x] `$expr` -> `$expr_str` へ変更
  - `hoge()?` に対して `fuga($expr)` をフックとしている場合 `fuga(hoge())?` になる
- `flavor_create! {}` マクロ
  - 現状tomlファイルを作らなくてもflavorを作れるので、だったらいっそそのまま書けるものも用意したら？と思った